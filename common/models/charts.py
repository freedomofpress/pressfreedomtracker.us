from datetime import datetime, timedelta, timezone

import structlog
from django.db import models
from django.db.models import Q
from marshmallow import Schema, fields
from wagtail.models import Collection
from wagtail.images import get_image_model_string, get_image_model

from common.exceptions import (
    PregenerationException,
    ChartNotAvailable,
)
from common.utils.chart_pregenerator.api import (
    request_snapshot,
)
from common.utils.chart_pregenerator.types import (
    ChartType,
    SnapshotType,
)


logger = structlog.get_logger()


class BaseChartOptionsSchema(Schema):
    """Base schema that consolidates data shared between the options
    of different types of charts."""
    tag = fields.Str(attribute='incident_set.tag', data_key='filterTags')
    filter_categories = fields.List(
        fields.Str(),
        data_key='filterCategories',
        attribute='incident_set.categories',
    )
    date_range = fields.Method('get_date_range', data_key='dateRange')
    width = fields.Int()
    height = fields.Int()

    def get_date_range(self, obj):
        lower = obj.get('incident_set', {}).get('lower_date', None)
        upper = obj.get('incident_set', {}).get('upper_date', None)
        if lower:
            lower = lower.isoformat()

        if upper:
            upper = upper.isoformat()
        return [lower, upper]


class VerticalBarChartOptionsSchema(BaseChartOptionsSchema):
    branch_field_name = fields.Function(lambda obj: obj.branch_field_name(), data_key='branchFieldName')
    branches = fields.Function(lambda obj: obj.branches())
    group_by_tag = fields.Str(data_key='groupByTag')
    time_period = fields.Str(data_key='timePeriod')


class BubbleMapChartOptionsSchema(BaseChartOptionsSchema):
    group_by = fields.Str(data_key='aggregationLocality')


class TreeMapOptionsSchema(BaseChartOptionsSchema):
    branch_field_name = fields.Function(lambda obj: obj.branch_field_name(), data_key='branchFieldName')
    branches = fields.Function(lambda obj: obj.branches())


class ChartSnapshot(models.Model):
    COLLECTION_NAME = 'Chart Snapshots'
    DEFAULT_HEIGHT = 800
    DEFAULT_WIDTH = 1190

    last_generated = models.DateTimeField(auto_now=True)
    chart_type = models.CharField(
        max_length=255,
        choices=ChartType.choices,
    )
    query = models.JSONField()
    snapshot_type = models.CharField(
        max_length=255,
        choices=SnapshotType.choices,
    )

    # These are the "cached" fields--things generated by the node service
    # that we then save
    chart_image = models.ForeignKey(get_image_model_string(), null=True, on_delete=models.CASCADE)
    chart_svg = models.TextField(null=True)

    class Meta:
        constraints = [
            models.CheckConstraint(
                check=(
                    Q(snapshot_type=SnapshotType.SVG, chart_svg__isnull=False) | (
                        Q(
                            snapshot_type=SnapshotType.PNG,
                            chart_image__isnull=False,
                        ) & ~Q(chart_image='')
                    )
                ),
                name='snapshot_type_requires_corresponding_chart'
            ),
            models.UniqueConstraint(
                fields=['query', 'chart_type', 'snapshot_type'],
                name='unique_types_and_query',
            )
        ]

    def is_stale(self):
        """Returns True if the chart is stale and needs to be regenerated."""
        now = datetime.now(tz=timezone.utc)
        age = now - self.last_generated
        return age > timedelta(days=1)

    def generate(self):
        try:
            result = request_snapshot(
                snapshot_type=self.snapshot_type,
                chart_type=self.chart_type,
                query=self.query,
            )
        except PregenerationException:
            logger.exception('Chart pregeneration failed')
            return

        previous_image = None
        if self.snapshot_type == SnapshotType.SVG:
            self.chart_svg = result
        elif self.snapshot_type == SnapshotType.PNG:
            custom_image = get_image_model()(
                file=result,
                # Remove the file extension for the title
                title=result.name.rsplit('.', 1)[0],
                collection=self.get_or_create_collection(),
                height=self.query.get('height', self.DEFAULT_HEIGHT),
                width=self.query.get('width', self.DEFAULT_WIDTH),
            )
            custom_image.save()
            previous_image = self.chart_image
            self.chart_image = custom_image
        self.save()

        # Remove previous image
        if previous_image:
            previous_image.delete()

    @classmethod
    def get_or_create_collection(cls):
        try:
            collection = Collection.objects.get(name=cls.COLLECTION_NAME)
        except Collection.DoesNotExist:
            return cls.create_collection()
        return collection

    @classmethod
    def create_collection(cls):
        root_collection = Collection.get_first_root_node()
        collection = Collection(name=cls.COLLECTION_NAME)
        root_collection.add_child(instance=collection)
        return collection

    @classmethod
    def get_or_generate(cls, chart_type, snapshot_type, query):
        try:
            chart = cls.objects.get(chart_type=chart_type, query=query, snapshot_type=snapshot_type)
        except cls.DoesNotExist:
            chart = cls(
                chart_type=chart_type,
                query=query,
                snapshot_type=snapshot_type,
            )
            chart.generate()

        if chart.pk:
            if chart.is_stale():
                chart.generate()
            return chart
        else:
            raise ChartNotAvailable
